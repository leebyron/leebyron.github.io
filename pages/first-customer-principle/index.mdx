---
layout: Article
title: First Customer Principle
date: 2021-09-01T13:30:00Z
published: false
tags:
  - Open Source
  - Software
---

> All new software should have exactly one first customer.

Software developers love to generalize. The moment we spot a second usage of a bit of logic or a sense common pattern emerging we're quick to jump to our generalization tools. *Create A Reusable Function. Don't Repeat Yourself. Abstract That Away.* And for good reason; we develop a keen nose for [code smells](https://en.wikipedia.org/wiki/Code_smell) and end up writing better software. This is where I find much of the "art" of coding, as well as most of the pleasure. Repeating yourself *feels bad*; a clean abstraction can be *beautiful*.

Generalization is also our Achilies' heel. Allowing ourselves to venture too far down this path can lead to lowest common denominator software which barely solves everyone's needs while not serving any specific need particularly well. It can also lead to rigid or fragile software where necessary changes are more challenging than they should be or might not be possible at all due to the constraints of the abstractions in place.

How do we stave off failure from over generalization? We set clear, focused, and concrete goals. Goals keep us grounded in the reality of *why* we're building something rather than just the art of it and provide context for understanding the costs and benefits of our technical decisions.

But what about if *the goal is to be a generalized solution?* Technical infrastructure like Kubernetes and open source software like React want to appeal to a broad range of customers and need to think about a near infinite number of ways their software could be used. These kinds of projects can not only fail in setting goals to counterbalance to our worst proclivities but *actively encourage them.*

I've spent the majority of my career working on "product infrastructure"—projects like GraphQL, React, Relay—which need to consider and support an incredible range of potential usage. After seeing such projects succeed and fail, I've come to a general principle for improving the odds, regaining clear focus, and curbing over generalization that I call the "First Customer Principle":

> All software, and especially infrastructure and open source software, should start with one and only one first customer.

## Constraints are powerful

We write software for a reason and the better we understand why a piece of software needs to exist, the better we software developers can do our jobs. We need clear goals and success criteria in order to define design constraints and thus [stoke creativity](https://www.toptal.com/designers/ui/design-constraints).

For important products, developers rarely work alone. We partner with business stakeholders, project managers, product designers and others. These people have their own proclivities, but they're less likely to appreciate the beauty of a generalized abstraction and may not be so tolerant of the time required to develop one. Developers building *products* are often frustrated by the rapid pace of progress, ruthless prioritization, and thus limited priority for deep technical work.

So I understand how by contrast technical infrastructure and open source can be a kind of Shangri-La. This work is often done by teams formed entirely of software developers serving customers who are also software developers.

In defining success as having the broadest possible usage,

 Where better to do deep technical work, share love for the art of programming, and in the name of having the most impact: *generalize*.

These open source projects often define success and set goals by scope of usage. How many downloads from a package manager or how many different companies are using our software? What gets easily lost is *why* . Why should  are we building this? How do we know if it is successful?


## Solve for now, not for later

## The path to open source




I've found that technical infrastructure and open source projects which aspire to be broadly used platforms,

  start with a single first customer.



What leads to over generalization, how do we push back against this instinct, and what kinds of software is most at risk?



## Answer "why" by setting clear goals

We write software for a reason and the better we understand why a piece of software needs to exist, the better us software developers can do our jobs. We need clear goals, success criteria, that help define design constraints and thus [stoke creativity](https://www.toptal.com/designers/ui/design-constraints).

For important goals, developers rarely work alone. We partner with business stakeholders, project managers, product designers and others. These people have their own tendencies, but they're less likely to appreciate the beauty of a generalized abstraction and may not be so tolerant of the time required to develop one. Developers building *products* are often frustrated by the pace of progress and limited priority for



I've spent the majority of my career working on "product infrastructure"—projects like GraphQL, React, Relay—which need to consider and support an incredible range of usage.